thread
basic unit of CPU utilization

if a process has multiple threads of control,
it can perform more than one task at a time
contain thread id , register and stack

benefit
responsiveness - allow program continue running even part of it is blocked ot perform lengthy operation
resource sharing - allow application to have several
					thread of activity within same address space 
economy - more economical to create and context_switch threads then costly process creation
utilization of multiprocessor architectures - threads may be running in parallel
												on different processors, multithreading
												increase concurrency

dining philosopher problem
philosopher need to eat, think and sleep

1. input : 
number of philosopher = number of philosopher and fork. if only one philosopher, only one fork
times to die = if philosopher didn't eat, times to die begin since their last meal
times to eat = time for philosopher to eat, need to hold both fork
times to sleep = time for philosopher to sleep
number of times philosopher to eat =  number of turn philosopher must eat, then stimulation stop
										if not specify, stimulation end when philosopher die

2. output:
report philosopher state changes
ms philosopher X has taken a fork
ms philosopher X is eating
ms philosopher X is sleeping
ms philosopher X is thinking
ms philosopher X die

replace ms with actual time and X with number of philosopher

define philosopher class
philosopher is thread
left fork and right fork is mutax lock

algorithm
1. start
2. declare and initialize thread variables (philosopher)
3. declare and initialize mutax variables (fork)
4. create the threads representing philosopher
5. wait until thread finish execution stop

algorithms for thread
1. start
2. philosopher lock left fork
3. philosopher lock right fork
4. philosopher is eating
5. philosopher unlock left fork
6. philosopher unlock right fork
7. sleep
8. think

function
1. pthread_mutex_init(&mutex, NULL) - initialize mutex
2. pthread_mutex_lock(&mutex) - lock a mutex
3. pthread_mutex_unlock(&mutex) - unlock a mutex
4. pthread_create(ptr to thread, NULL, (void*)func, (void*))
5. pthread_join(ptr to thread, &msg) - make the main program wait
called thread is finished executing it's task
6. pthread_mutex_destroy (ptr to thread)
7. pthread_exit(NULL)


BONUS

fork is representing with semaphore
a philosopher try to grab fork by wait() on that semaphore
a philosopher release fork by signal() on that semaphore
semaphore fork[5]
semaphore initialize to 1 mean free
semaphore initialize to 0 mean not free

do {
	wait (fork[i]);
	wait (fork[(i + 1) % 5]);  // to handle last philosopher

	...
	// eat
	signal(fork[i]);
	signal(fork[(i + 1) % 5]);

	// think
} while (TRUE);

deadlock - all five philosophers become hungry simulateneusly
and grabs their left fork. No more fork left. When each philosopher
tries to grab his right fork, he will delayed forever.